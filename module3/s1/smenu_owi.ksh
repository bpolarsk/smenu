#!/bin/sh
# author   : b. polarski
# Program  : Owi interface (spl)
# Note     : This is the query part of the smenu sampling. It uses the fake 'spl' shortcuts
#            Which in fact covers many various script. The drivin one is 'smenu_menu_monitor.ksh'
# date     : 2005 Nov 13
# Modified   2006 Apr 8     : Added all SINGLE option
 set -x
ARGS="$@"
FOUT=$SBIN/tmp/spl_$$.log

# ------------------------------------------------------------------------------------
function help
{
 more <<EOF

          spl -h   : This help
          spl -h1  : Stop and start a sampler
          spl -h2  : Manage ascii files
          spl -h3  : Query the sample files
          spl -h4  : Examples

EOF
exit
}
# ------------------------------------------------------------------------------------
function h1
{
  more <<EOF
                    .......................................
                    .                                     .
                    .     Sample Oracle waits interface   .
                    .                                     .
                    .......................................

START/STOP:
-----------
     spl stand for 'sampler'. It is a set of scripts issued to exploit the Oracle wait interface.
     'spl' generate a sampling process to download facts in an ascii files. It dumps all waits events 
     from v\$session_wait every second and also generates a file with all sql texts that appear during the 
     sample duration. Last the figures for the sql from v\$sql are also downloaded.

     To start or stop a sampler : 

               spl start  -l <duration minute> -i <sec> -s <sec> <-perl> -u <owner> -p <passwd@SID>
               spl stop
 
         -l : duration of sampler in seconds: default is 1800
         -i : interval of dump for OWI, default is 1 second
         -s : interval of dump in seconds for SQL figures: default is 60

     Next, you have a generated a set of ascii files that contains sample informations from the Oracle waits 
     interface.  These ascii files are queried through external tables (dba_external_locations) whose definition
     is contained in SBIN/SELECT. Spl guarantee that the correct file is associated with the up-todate directory 
     definition using the correct table definition.  You can check it with 'tbl -ext'.  
     Note : Spl takes by default the latest files for the current SID. To query a file, the file must be local
     to the Oracle Server. If you use a remote DB to query the files, the files must be on this remote DB disks.

     spl will try to use the default user to connect and extract its password from SBIN/.password. 
     You can nevertherless provide all this:

        spl start -o PRODB -u system [-p <PASSWD> ]      # this will start the PL/SQL sampler

     If your default user is 'SYS' then it will use '/ as sysdba' and no need password.

     The sampler exists in PL/SQL and in Perl. The PL/SQL is called by default, but you can call a remote DB
     and have the ascii files generated locally with the perl sampler:

       spl start -perl -u <OWNER> -p <password@SID>

       
EOF
exit
}
# ------------------------------------------------------------------------------------
function h2
{
  more <<EOF
                    .......................................
                    .                                     .
                    .     Manage Ascii files              .
                    .                                     .
                    .......................................

RENAME/PACK :  manage the ASCII files
--------------------------------------
     If you used the perl sampler to get measuremment from a remote DB, you created local files for a remote
     DB. In Order to query these ascii files, Smenu needs to create a directory. but directory can only be local 
     to a DB server. So the trick is to rename these ascii file gathered on a remote system to the local DB SID

          spl -rename -o <REMOTE SID> [-n <LOCAL SID>] [-d <date>] [-dir <dir_path>]
          spl -pack -o <SID>  [-d <date>] [-d <date>]....   [-dir <dir_path>]

 
           -dir :  files and operation are in <dir_path>. default is \$SBIN/tmp
 
       RENAME : ie) Given that my local DB is TESTDB

           spl -rename -o DBPROD -d 3100945

           This rename files generated for Remote DBPROD the 31/09 at 09:45 to the name of local TESTDB with 
           same timestamp.  Now I can easily mount the ascii file as if they were generated by this DB. 

       PACK   : ie) collapse all file of various sets <SID> into one set. This is usefull to aggregate files 
                    or import prepare import into a DB to study off site. date argument are the date extention name 
                    of the sample set.  If not date arugment are given then all files of the current SID are 
                    collapsed into a new one. The new date extention name will be of the current system date.

           spl -pack                                      # Collapse all sets f current SID into a single set
           spl -pack -o <SID> -d <mmddHHMI> -d <mmddHHMI> # Collapse 2 sets of SID into a new single set
 
EOF
exit
}
# ------------------------------------------------------------------------------------
function h3
{
  more <<EOF
                    .......................................
                    .                                     .
                    .       QUERY THE SAMPLE SET          .
                    .                                     .
                    .......................................

     Once you gathered the information, you want to query it. use the same shortcuts 'spl' for that.
     Here are all options available to produce reports and images. Images can be also immediatly view into a tabed 
     browser, allowing for you to create many in order to choice the best ones to add into your performance reporting.

     spl -d <DIR> -s <SID_ddhhmmss> -t [-hv <SQL_ID>] 
     spl -t   [-hv <SQL_ID>]   : Top events, group by event, segment_name; optional limit to an hash value
     spl -t2  [-hv <SQL_ID>]   : Top events, group by event,p1,p2 ; optional limit to an hash value
     spl -enq                          : Show all enqueue events and enqueue type (count enqueue)
     spl -enqh                         : Show enqueue events, group by slq_id (list sql with enqueue)
     spl -tseg                         : Top events, give segment name per slq_id, when applicable
     npl -ev                           : List top 10 events in sample for all event
     spl -ev <EVENT NAME>              : List top 10 events in sample for specific event. Name must exist in v$event_name

     spl -de  <SQL_ID> -gr <n> : extract delta for SQL_ID  (give results only for one sql_id)
                                         group sample by <n> minutes
     spl -pf <sid|mod|act>             : List contents of events metric per Session(sid),module(mod),action(act)
     spl -p mod|act <name>             : spl -p mod my_module
     spl -p sid <sid> <serial>         : spl -p sid 12 567
  #add (d) to have more columns : ie spl -dwx 
     spl -(d)w  -img  -rn <ROWS>         : Display all sql values Sort by rows processed
     spl -(d)r  -img  -rn <ROWS>         : Display all sql values Sort by disk_reads
     spl -(d)g  -img  -rn <ROWS>         : Display all sql values Sort by buffer gets
     spl -(d)x  -img  -rn <ROWS>         : Display all sql values Sort by executions
     spl -(d)wx  -img  -rn <ROWS>        : Display all sql values Sort by rows/execution
     spl -(d)rx  -img  -rn <ROWS>        : Display all sql values Sort by disk reads/executions
     spl -(d)gx  -img  -rn <ROWS>        : Display all sql values Sort by buffer/executions

     spl -img -rw -rn <ROWS>           : List SQL sorted by disk_reads/rows
     spl -img -gw -rn <ROWS>           : List SQL sorted by buffer_gets/rows

     You can pile the arguments, in this case the SQL is sorted by the first argument :

      spl -img -g -r -w -x

Defaults values used: when
---------------------------

       If DIR is not given then $SBIN/tmp is used.
       if file extention is not givent then latest file for the current ORACLE_SID is used.

       -s   : Oracle SID and time in the name of the sample file
       -d   : SAMPLE_DIR

Filter display :
----------------

      -gr   : group by minutes <min>, only valid for option '-de'
              ie: spl -de <HASH_VALUE> -gr 5 -img

      -hv   : Give SQL text for SQL_ID. When -hv is added to -t/-t2, 
              the default retrieved rows rise from 10 to 50
      -rn   : number of rows to display (default 10)
 -min <n>   : start n Minutes from the last entry in sample.
                  If your sampler is running, then the effect is it gives the last n minutes.
                  ie ) spl -min 5 -w will give the top desc rows processed for the last 5 minutes
     -clist : list all available colors
     -cl    : "list of colors"
EOF
exit
}
# ------------------------------------------------------------------------------------
function h4
{
  more <<EOF
                    .......................................
                    .                                     .
                    .         Examples                    .
                    .                                     .
                    .......................................

     A)  At 10h00 you want to start a sampler of 4 hours:

            spl start -l 240                      # it will stop automatically after 240 minutes
                                                  # You can stop it before with 'spl stop'

         You can have the type of events already catched :

            spl -ev

 Nbr Wait Event name                      WAIT_TIME  Perc   Object name
--------- ------------------------------ ---------- ------- ---------------------------
     9005 i/o slave wait                      32468   42.69
     1774 Queue Monitor Wait                 269290    8.41
     1101 db file sequential read                14    5.22
     1005 latch: cache buffers chains          4103    4.76
      745 db file sequential read              4973    3.53
      464 io done                                 1    2.20
      247 jobq slave wait                      7053    1.17
      218 db file sequential read                 4    1.03
      209 db file sequential read                28    0.99
      157 db file sequential read                 0    0.74


      B) You want to see the distribution for "latch: cach buffers chains". Just type spl -ev and 
         cut and past the string text "latch: cache buffers chains"

            spl -ev "latch: cache buffers chains"                # double quotes are not needed

                                                                   Sample
 Nbr Wait Event name                     SQL_ID  WAIT_TIME  Perc   Object name
--------- ------------------------------ -------------- ---------- ------- ---------------------------
     1005 latch: cache buffers chains        1323209015       4103    4.76
       32 latch: cache buffers chains        4231337329        257    0.15
       19 latch: cache buffers chains        1323209015         87    0.09
       16 latch: cache buffers chains         815308336          4    0.08 PUBLIC./2ccf0331_Method
       10 latch: cache buffers chains         815308336          6    0.05 PUBLIC.sun/misc/Timeable
        7 latch: cache buffers chains        4231337329         16    0.03 SYS./724f4e6d_Builder

 

      C)  You would like to know which SQL is waiting on witch object and what it is waiting:

            spl -tseg 


  Nbr                                 SQL        Time    Sample
 waits  Event name                 Hash Value    waits    Perc   Segment name                       Type
------- ------------------------- ------------ --------- ------- -------------------------------- ---------
     15 db file sequential read     2834669896         0    0.07 SYS_LOB0000049528C00007$$        LOBSEGMENT
      3 db file sequential read      475547433         0    0.01 SYS_LOB0000049528C00007$$        LOBSEGMENT
      3 db file sequential read     2240780814         0    0.01 SYS_LOB0000049528C00007$$        LOBSEGMENT


      D)  While the sampler was running or after you asked the top 10 sorted by 
          execution, buffer gets, row_processed, disk_reads and you want a graphic also:

               spl -x -g -r -d  -img


      E)  You notice query HASH_VALUE 345678 is the top. You retrieve its text with:

             spl -hv 345678

          At 15h30 you are asked about a graphich for query HASH_VALUE 345678 behaviour between 12h30 and 13h00 
          Information will be given grouped by 5 minutes. You must go back from the top of the file (14h00)
 
             spl -min 90 -de 345678 -gr 5 -rn 6 -img

          This will display starting from 13h30, 6 lines, each line will sum up the activity for 5 minutes
          for rows_processed, buffer_gets, disk_reads, executions, sorts, cpu_time. The first line is the
          situation at the start of display

Start date : 20060331100018       Total entries in sample file:      65246
End date   : 20060331140045       SQL_ID              : 1016061570

TIME     ROWS_PROCESSED  DISK_READS  EXECUTIONS  BUFFER_GETS     SORTS       CPU_TIME
-------- --------------  ----------  ----------  -----------   ----------   ---------
13:28:21      1137152         1514      2535755      6208601            0 170.643937
-------#
13:33:36       454193            0       908387      2270967            0  55.750733
13:38:51       153683           15       359731       873145            0  21.109466
13:44:06            3            3            9           21            0     .00066
13:49:21            1            4            3            7            0    .000447
13:54:36            2            4            4           10            0    .000411
13:57:45            0            0            0            0            0          0


      F)  If you have a sample of 24h and want to have the detail of a query by hour you will type:

             spl -min 1440 -de <HASH_VALUE> -gr 60 

          if you want only the last 12h summing the activity of each hour a graphic:

             spl -min 720 -de <HASH_VALUE> -gr 60 -img   

      G)  Your database is slow, you started a sampler and want to retrieve all infos sorted executions 
          for the last 15 minutes:

             spl -min 15 -dx :

                                                                                              Disk
HASH_VALUE ROWS_PROCESSED DISK_READS BUFFER_GETS EXECUTIONS  Bufs/Exec  Rows/Exec Reads/Exec   CPU_TIME
---------- -------------- ---------- ----------- ---------- ---------- ---------- ---------- ----------
1016061570         680822         26     3508850    1414014          2          0          0          0
 545138317         785587          1     1571174     785587          2          1          0          0
4010258057         226007          0           0     226010          0          1          0          0
 921443695         166362         28      833422     166367          5          1          0          0
3119962695         164954       1080     1822700     164954         11          1          0          0
.
.

EOF
 exit
}
# ------------------------------------------------------------------------------------
function is_and
{
   if [ -n "$WHERE_STATEMENT" ];then
      AND=and
   else 
     AND=""
   fi 
   echo $AND
}
# ------------------------------------------------------------------------------------
function check_correct_external 
{
set -x
TBL=$1
v_spl_sid=$SPL_SID
v_spl_nbr=$SPL_NBR
case $TBL in
  SAMPLE_SQL_W   ) FSQL_W=sample_sql_w_${SPL_SID}.${SPL_NBR} ;;
  SAMPLE_TXT_W   ) FSQL_W=sample_txt_w_${SPL_SID}.${SPL_NBR} ;;
  SAMPLE_DELTA_W ) FSQL_W=sample_delta_w_${SPL_SID}.${SPL_NBR} ;;
  SAMPLE_EVT_W   ) FSQL_W=sample_evt_w_${SPL_SID}.${SPL_NBR} ;;
esac

# check if the external definition is correct
var=`sqlplus -s "$CONNECT_STRING" <<EOF
set feed off pagesize 0 head off
select 
         count(1) 
from 
      dba_external_locations 
where     table_name     = '$TBL' 
      and DIRECTORY_NAME = 'SAMPLER_W_DIR' 
      and LOCATION         =  '$FSQL_W';
EOF`
ret=`echo $var | awk '{print $1'}`
if [ $ret -lt 1 ];then
   $SBINS/SELECT -cc $FSQL_W
#elif [ ! -f $FSQL_W ];then
#   echo "Cannot find $FSQL_W"
#   exit 1
fi
}
# ------------------------------------------------------------------------------------
if [ -z "$1" ];then
    help
fi
MIN=1440
ROWNUM=10
tlen=27
unset CREATE_IMAGE
GR_MIN=0;
while [ -n "$1" ]; do
   case "$1" in
      -d ) SAMPLE_WORK_DIR=$2  
           shift;;
    -min ) MIN=$2 ; shift ;;
    -g   ) MODULE=IMG_COL ; SORT=${SORT:-BUFFER_GETS}
           SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, b.buffer_gets - a.buffer_gets buffer_gets" 
           SELECT_LIST="$SELECT_LIST, BUFFER_GETS" 
           SUM_FIELD="$SUM_FIELD, sum(buffer_gets) buffer_gets" 
           ;;
    -w   ) MODULE=IMG_COL ; SORT=${SORT:-ROWS_PROCESSED}
           SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, b.rows_processed - a.rows_processed rows_processed" 
           SELECT_LIST="$SELECT_LIST, rows_processed" 
           SUM_FIELD="$SUM_FIELD, sum(rows_processed) rows_processed" 
           ;;
    -r   ) MODULE=IMG_COL ; SORT=${SORT:-DISK_READS}
           SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, b.disk_reads - a.disk_reads disk_reads" 
           SELECT_LIST="$SELECT_LIST, disk_reads" 
           SUM_FIELD="$SUM_FIELD, sum(disk_reads) disk_reads" 
           ;;
    -x   ) MODULE=IMG_COL ; SORT=${SORT:-EXECUTIONS} 
           SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, b.executions - a.executions executions" 
           SELECT_LIST="$SELECT_LIST, executions" 
           SUM_FIELD="$SUM_FIELD, sum(executions) executions" 
           ;;
    -wx   ) MODULE=IMG_COL ; SORT=${SORT:-RATIO_w} 
           SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, decode(b.executions-a.executions, 0,0 ,(b.rows_processed-a.rows_processed)/(b.executions-a.executions)) ratio_w"
           SELECT_LIST="$SELECT_LIST, ratio_w" 
           ADD_SUM_EXEC=TRUE 
           ADD_SUM_ROWS=TRUE 
           ;;
    -gx   ) MODULE=IMG_COL ; SORT=${SORT:-RATIO_G} ; SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, decode(b.executions-a.executions, 0,0 ,(b.buffer_gets-a.buffer_gets)/(b.executions-a.executions)) ratio_g"
           SELECT_LIST="$SELECT_LIST, ratio_g" 
           ADD_SUM_EXEC=TRUE 
           ADD_SUM_GETS=TRUE 
           ;;
    -rx   ) MODULE=IMG_COL ; SORT=${SORT:-RATIO_R} ; SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, decode(b.executions-a.executions, 0,0 ,(b.disk_reads-a.disk_reads)/(b.executions-a.executions)) ratio_r"
           SELECT_LIST="$SELECT_LIST, ratio_r" 
           ADD_SUM_EXEC=TRUE 
           ADD_SUM_READS=TRUE 
           ;;
    -rw   ) MODULE=IMG_COL ; SORT=${SORT:-RATIO_RW} ; SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, decode(b.rows_processed-a.rows_processed, 0,0 ,(b.disk_reads-a.disk_reads)/(b.rows_processed-a.rows_processed)) ratio_rw"
           SELECT_LIST="$SELECT_LIST, ratio_rw" 
           ADD_SUM_READS=TRUE 
           ADD_SUM_ROWS=TRUE 
           ;;
    -gw   ) MODULE=IMG_COL ; SORT=${SORT:-RATIO_GW}  ; SORT_H=$SORT ; 
           DIFF_FIELDS="$DIFF_FIELDS, decode(b.rows_processed-a.rows_processed, 0,0 ,(b.buffer_gets-a.buffer_gets)/(b.rows_processed-a.rows_processed)) ratio_gw"
           SELECT_LIST="$SELECT_LIST, ratio_gw" 
           ADD_SUM_GETS=TRUE 
           ADD_SUM_ROWS=TRUE 
           ;;
    -de  ) MODULE=DELTA ; HV=$2 ; shift ;;
    -gr  ) GR_MIN=$2  ; shift ;;
    -dw  ) MODULE=DELTA ; SORT=ROWS_PROCESSED ; SORT_H=$SORT;;
    -dr  ) MODULE=DELTA ; SORT=DISK_READS ; SORT_H=$SORT;;
    -dg  ) MODULE=DELTA ; SORT=BUFFER_GETS; SORT_H=$SORT ;;
    -dx  ) MODULE=DELTA ; SORT=EXECUTIONS ; SORT_H=$SORT ;;
    -dwx ) MODULE=DELTA ; SORT=ratio_w; SORT_H="Ratio Rows/Executions" ;;
    -drx ) MODULE=DELTA ; SORT=ratio_r ;  SORT_H="Ratio disk reads/Executions";;
    -dgx ) MODULE=DELTA ; SORT=ratio_g ;  SORT_H="Ratio Buffer gets/Executions";;
     -t  ) MODULE=TOP10_WAIT 
           SQL_ID=" sql_id," 
           tlen=40;;
     -t2 ) MODULE=TOP10_WAIT  
           P1P2=" p1,p2, " 
           unset SQL_ID 
           tlen=27;;
     -ev ) MODULE=TOP10_WAIT  
           unset SQL_ID 
           tlen=27
           if [ -n "$2" ];then
              shift
              while [ -n "$2" ]; do
                  TOP_EVENT="${TOP_EVENT}${SPACE}$1"
                  SPACE=' '
                  shift
              done
              TOP_EVENT="$TOP_EVENT${SPACE}$1"
           fi;;
    -enq ) MODULE=ENQUEUE  
           unset SQL_ID 
           tlen=27;;
    -enqh ) MODULE=ENQUEUE  
           SQL_ID=" sql_id," 
           tlen=27;;
   -tseg ) MODULE=TSEG  ;;
      -s ) SPL=$2 ; shift;;
     -s1 ) SPLD=$2 ; shift;;
     -h )  help;;
     -h1 ) h1;;
     -h2 ) h2;;
     -h3 ) h3;;
     -h4 ) h3;;
     -hv ) SHOW_SQL=YES
           HV=$2 
           shift;;
     -img) CREATE_IMAGE="$SBIN/module3/s1/smenu_create_img.ksh $ARGS -f $FOUT" ;;
       -rn) ROWNUM=$2 ; OVER_ROW=1;
           shift ;;
     -pf ) MODULE=PF_COUNT; GROUP_BY=$2 ; shift ;;
     -p  ) MODULE=PF_LIST
           case "$2" in
              mod|MOD ) GROUP_BY=MOD; F_VALUE=$3; shift; shift ;;
              act|ACT ) GROUP_BY=ACT; F_VALUE=$3; shift; shift ;;
              sid|SID ) GROUP_BY=SID; F_VALUE1=$3 ; F_VALUE2=$4;  shift; shift ;shift ;;
           esac
           ;;
  -clist ) echo "\n\n  white, lgray, gray, dgray, black, lblue, blue, dblue, gold, lyellow, yellow, dyellow,
  lgreen, green, dgreen, lred, red, dred, lpurple, purple, dpurple, lorange, orange, 
  pink, dpink, marine, cyan, lbrown, dbrown\n\n" 
           exit ;;
  -cl    ) COLOR_LIST="$2" ; shift  ;; # this will be passed as it to create_img.ksh
       * ) echo "Unknow parameter $1" ; help ;;
   esac
   shift
done
OVER_ROW=${OVER_ROW:-0};
if [ -z "$SAMPLE_WORK_DIR" ];then
   echo "Using default SAMPLE_WORK_DIR"
   SAMPLE_WORK_DIR=$(pwd) 
fi
cd $SAMPLE_WORK_DIR
if [ -z "$SPL"  ];then
   echo "Using default SPL"
   SPL=$ORACLE_SID.`ls -t sample_sql_w_$ORACLE_SID.*|head -1|sed 's/.*\([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]\)/\1/'`
fi

if [ "$ADD_SUM_EXEC" = TRUE ];then
   echo $SUM_FIELD | grep -q "sum(executions)"
   if [ $? -eq 0 ];then
        : # Already there so we don't need to add it
   else
           SUM_FIELD="$SUM_FIELD, sum(executions) executions" 
   fi
fi

if [ "$ADD_SUM_ROWS" = TRUE ];then
   echo $SUM_FIELD | grep -q "sum(rows_processed)"
   if [ $? -eq 0 ];then
        : # Already there so we don't need to add it
   else
        SUM_FIELD="$SUM_FIELD, sum(rows_processed) rows_processed" 
   fi
fi
if [ "$ADD_SUM_GETS" = TRUE ];then
   echo $SUM_FIELD | grep -q "sum(buffer_gets)"
   if [ $? -eq 0 ];then
        : # Already there so we don't need to add it
   else
        SUM_FIELD="$SUM_FIELD, sum(buffer_gets) buffer_gets" 
   fi
fi
if [ "$ADD_SUM_READS" = TRUE ];then
   echo $SUM_FIELD | grep -q "sum(disk_reads)"
   if [ $? -eq 0 ];then
        : # Already there so we don't need to add it
   else
        SUM_FIELD="$SUM_FIELD, sum(disk_reads) disk_reads" 
   fi
fi


PROMPT="prompt  .     Type 'spl -h' for help          Displaying $ROWNUM rows"

SPL_SID=`echo $SPL |sed 's/\(.*\).[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]/\1/'`
SPL_NBR=`echo $SPL |sed 's/.*\([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]\)/\1/'`

S_USER=SYS
. $SBIN/scripts/passwd.env
. ${GET_PASSWD} SYS $ORACLE_SID

if [  "x-$CONNECT_STRING" = "x-" ];then
   echo "could no get a the password of $S_USER"
   exit 0
fi

# .................................................................
if [ "$MODULE" = "IMG_COL" ];then
   check_correct_external SAMPLE_DELTA_W 
   echo "MACHINE $HOSTNAME - ORACLE_SID : $ORACLE_SID                                                   Page: 1"

#cat <<EOF
   sqlplus -s "$CONNECT_STRING" <<EOF
set heading off embedded off pause off verify off feed off pause off linesize 90 pagesize  999
column nline newline
column mindd new_value mindd noprint
column maxdd new_value maxdd noprint
select min(b.ddate) mindd from (select max(ddate) maxd from sys.sample_delta_w ) a, sys.sample_delta_w b  
	      	    where to_date(b.ddate,'YYYYMMDDHH24MISS') > to_date(a.maxd,'YYYYMMDDHH24MISS')-$MIN/1440
/
select max(ddate) maxdd from sys.sample_delta_w 
/
column sql_ID format a13 head 'SQL|Hash Value' justify c
column rows_processed format 999999999 head "ROWS_PROCESSED"  justify c
column buffer_gets format 999999999 head "BUFFER_GETS"    justify c
column executions format 999999999 head "EXECUTIONS"      justify c
column disk_reads format 999999999 head "DISK_READS"      justify c
column ratio_w  format 999999999 head "ROWS/EXEC"         justify c
column ratio_r  format 999999999 head "DISK_READS/EXEC"   justify c
column ratio_g  format 999999999 head "BUFFER_GETS/EXEC"  justify c
column ratio_rw format 999999999 head "DISK_READS/ROWS"   justify c
column ratio_gw format 999999999 head "BUFFER_GETS/ROWS"  justify c
column tot new_value tot noprint
column ftime format A10 new_value ftime noprint
spool $FOUT
select 'Date              -  '||to_char(sysdate,'Day Ddth Month YYYY  HH24:MI:SS'),
       'Username          -  '||USER nline,
       'Report            -  List Sample Delta', ' ' nline,
       'From              -  ' || 
to_char(to_date(&mindd,'YYYYMMDDHH24MISS'),'YYYY-MM-DD    HH24:MI:SS') || '  -->  ' ||
to_char(to_date(&maxdd,'YYYYMMDDHH24MISS'),'HH24:MI:SS') nline from sys.dual
/
set heading on
select  ftime, sql_id $SELECT_LIST
from (
  select 
    trunc(to_number(to_date(b.ddate,'YYYYMMDDHH24MISS') - to_date(a.ddate,'YYYYMMDDHH24MISS')) * 24*60)
    || 'Min'||mod(trunc(to_number(to_date(b.ddate,'YYYYMMDDHH24MISS')+1 - to_date(a.ddate,'YYYYMMDDHH24MISS'))
    * 24*60*60),60) ftime,
    a.sql_id
    $DIFF_FIELDS
  from
      (select ddate, sql_id $SUM_FIELD
              from 
                   sys.sample_delta_w where ddate = &mindd 
              group 
                   by ddate,sql_id order by sql_id
      )a, 
      (select  ddate, sql_id $SUM_FIELD
              from sys.sample_delta_w where ddate = &maxdd group by ddate, sql_id order by sql_id
      )b
  where b.sql_id = a.sql_id 
  order by $SORT desc 
) where rownum <= $ROWNUM
/
prompt
prompt Sample duration : &ftime
EOF
# .................................................................
elif [ "$MODULE" = "DELTA" ];then
   if [ -z "$HV" -a -z "$SORT" ];then
      echo "I need a hash value "
      exit 1
   fi
   check_correct_external SAMPLE_DELTA_W 
   if [ -n "$SORT" ];then

   # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   #  Delta between begin and end sorted by disk_reads
   # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   echo "MACHINE $HOSTNAME - ORACLE_SID : $ORACLE_SID                                                   Page: 1"
   sqlplus -s "$CONNECT_STRING" <<EOF
set heading off embedded off pause off verify off feed off pause off
set linesize 124 pagesize 66
column nline newline
column mindd new_value mindd noprint
column maxdd new_value maxdd noprint
select min(b.ddate) mindd from (select max(ddate) maxd from sys.sample_delta_w ) a, sys.sample_delta_w b  
	      	    where to_date(b.ddate,'YYYYMMDDHH24MISS') > to_date(a.maxd,'YYYYMMDDHH24MISS')-$MIN/1440
/
select max(ddate) maxdd from sys.sample_delta_w 
/

column sql_id format a13 head 'SQL|Hash Value' justify c
column tot new_value tot noprint
column ftime format A10 new_value ftime noprint
column ratio_g format 999999999 head "Bufs/Exec" 
column ratio_w format 999999999 head "Rows/Exec" 
column ratio_r format 999999999 head "Disk|Reads/Exec"  justify c
break on time
spool $FOUT
select 'Date              -  '||to_char(sysdate,'Day Ddth Month YYYY  HH24:MI:SS'),
       'Username          -  '||USER,
       'Report            -  List Sample Delta', ' ' nline,
       'From              -  ' || 
to_char(to_date(&mindd,'YYYYMMDDHH24MISS'),'YYYY-MM-DD    HH24:MI:SS') || '  -->  ' ||
to_char(to_date(&maxdd,'YYYYMMDDHH24MISS'),'HH24:MI:SS') nline from sys.dual
/
set heading on
$PROMPT ordered by $SORT_H
select ftime, sql_id,rows_processed, disk_reads, buffer_gets, executions, ratio_g, ratio_w, ratio_r, cpu_time
from (
  select 
    trunc(to_number(to_date(b.ddate,'YYYYMMDDHH24MISS') - to_date(a.ddate,'YYYYMMDDHH24MISS')) * 24*60) 
    || 'Min'||mod(trunc(to_number(to_date(b.ddate,'YYYYMMDDHH24MISS')+1 - to_date(a.ddate,'YYYYMMDDHH24MISS')) 
    * 24*60*60),60) ftime
    ,a.sql_id, b.rows_processed - a.rows_processed rows_processed,
    b.disk_reads - a.disk_reads disk_reads,
    b.executions - a.executions executions,
    b.buffer_gets - a.buffer_gets buffer_gets, 
    decode(b.executions-a.executions, 0,0 ,(b.buffer_gets-a.buffer_gets)/(b.executions-a.executions)) ratio_g,
    decode(b.executions-a.executions, 0,0 ,(b.rows_processed-a.rows_processed)/(b.executions-a.executions)) ratio_w,
    decode(b.executions-a.executions, 0,0 ,(b.disk_reads-a.disk_reads)/(b.executions-a.executions)) ratio_r,
    b.cpu_time - b.cpu_time cpu_time
  from
      (select ddate, sql_id,
              sum(ROWS_PROCESSED) rows_processed, sum(DISK_READS) disk_reads, sum(EXECUTIONS) executions, 
              sum(BUFFER_GETS) buffer_gets,  sum(CPU_TIME) cpu_time
              from sys.sample_delta_w where ddate = &mindd
      group by ddate,sql_id order by sql_id)a, 
      (select ddate, sql_id,
              sum(ROWS_PROCESSED) rows_processed, sum(DISK_READS) disk_reads, sum(EXECUTIONS) executions, 
              sum(BUFFER_GETS) buffer_gets, sum(CPU_TIME) cpu_time
              from sys.sample_delta_w where ddate = &maxdd
                   group by ddate, sql_id order by sql_id
      )b
  where b.sql_id = a.sql_id 
      order by $SORT desc 
) where rownum <= $ROWNUM
/
prompt
prompt Sample duration : &ftime
EOF

   # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   else   # delta for an sql_id
   # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   echo "MACHINE $HOSTNAME - ORACLE_SID : $ORACLE_SID                                                   Page: 1"
   #CHAR_DATE=${CHAR_DATE:-to_char(to_date(ddate,\'YYYYMMDDHH24MISS\'),\'HH24:MI:SS\') }
#   cat <<EOF
   sqlplus -s "$CONNECT_STRING" <<EOF
set heading off embedded off pause off verify off feed off pause off
set linesize 125
set pagesize 66
spool $FOUT
column nline newline
select 'Date              -  '||to_char(sysdate,'Day Ddth Month YYYY  HH24:MI:SS'),
       'Username          -  '||USER,
       'Report            -  List Delta for $HV nline'
from sys.dual
/
$PROMPT
set heading on
column sql_id format a13 head 'SQL|Hash Value' justify c
column tot new_value tot noprint
column mindd new_value mindd noprint
column maxdd new_value maxdd noprint

select min(b.ddate) mindd from (select max(ddate) maxd from sys.sample_delta_w ) a, sys.sample_delta_w b  
	      	    where to_date(b.ddate,'YYYYMMDDHH24MISS') > to_date(a.maxd,'YYYYMMDDHH24MISS')-$MIN/1440
/
select count(1) tot, max(ddate) maxdd from sys.sample_delta_w 
/
prompt Start date : &mindd       Total entries in sample file: &tot
prompt End date   : &maxdd       SQL_ID              : $HV
prompt
set serveroutput on size 990000
prompt TIME     ROWS_PROCESSED  DISK_READS  EXECUTIONS  BUFFER_GETS     SORTS       CPU_TIME
prompt -------- --------------  ----------  ----------  -----------   ----------   ----------

declare
cpt number;
rn number ;
over_row number ;
next_time date ;
old_rp number ;
old_dr number ;
old_ex number ;
old_bg number ;
old_sr number ;
old_ct number ;
acc_dr number ;
acc_rp number ;
acc_ex number ;
acc_bg number ;
acc_sr number ;
acc_ct number ;
flag number;
gr_min number;
frp varchar2(12) ;
fdr varchar2(12) ;
fsr varchar2(12) ;
fex varchar2(12) ;
fbg varchar2(12) ;

old_time  varchar2(14);
fct varchar2(12) ;
ddate varchar2(8);
begin
 over_row:=$OVER_ROW;
 rn:=$ROWNUM;
 gr_min:=$GR_MIN ;
 old_rp:=0;
 old_dr:=0;
 old_ex:=0;
 old_bg:=0;
 old_sr:=0;
 old_ct:=0;
 acc_rp:=0;
 acc_dr:=0;
 acc_ex:=0;
 acc_bg:=0;
 acc_sr:=0;
 acc_ct:=0;
 flag:=0;
 old_time:=''; 
 fdr:='0';
 cpt:=0;

 for p in ( select  to_char(to_date(ddate,'YYYYMMDDHH24MISS'),'HH24:MI:SS') Time, 
                  sum(ROWS_PROCESSED) ROWS_PROCESSED , sum(DISK_READS) DISK_READS, sum(EXECUTIONS) EXECUTIONS, 
                  sum(BUFFER_GETS) BUFFER_GETS, sum(SORTS) SORTS, sum(CPU_TIME) CPU_TIME
       from sys.sample_delta_w where sql_id = '$HV'  
       and  to_date(ddate,'YYYYMMDDHH24MISS') > to_date('&mindd','YYYYMMDDHH24MISS')
       group by sql_id, to_char(to_date(ddate,'YYYYMMDDHH24MISS'),'HH24:MI:SS') )
  LOOP

     if (to_date(p.Time,'HH24:MI:SS') > next_time and flag > 0 ) then
        next_time:=to_date(p.time,'HH24:MI:SS') + gr_min/1440 ;
        if ( flag=2) then
           dbms_output.put_line('         -------#');
           flag:=3;
        end if ;
        cpt:=cpt+1;
        if ( over_row > 0 and cpt > rn ) then
             exit ;
        end if ;
        dbms_output.put_line(old_time||' ' ||frp ||' '|| fdr || ' '||fex || ' '||fbg|| ' '|| fsr||' '||fct);
--dbms_output.put_line('over=' || to_char(over_row)|| '   cpt='||to_char(cpt));
        frp:='';
        acc_rp:=0;
        fdr:='';
        acc_dr:=0;
        fex:='';
        acc_ex:=0;
        fbg:='';
        acc_bg:=0;
        fsr:='';
        acc_sr:=0;
        fct:='';
        acc_ct:=0;
     end if ;

     -- #------- Processed ----------
     if ( (p.rows_processed-old_rp)>= 0 ) then 
        acc_rp:=acc_rp + (p.rows_processed-old_rp);
     else
         acc_rp:=acc_rp+p.rows_processed;
     end if;
     frp:=to_char(acc_rp,'99999999990');

     -- #------ Disk reads ----------
     if ( (p.disk_reads-old_dr)>= 0 ) then 
          acc_dr:=acc_dr+(p.disk_reads-old_dr);
     else
         acc_dr:=acc_dr+p.disk_reads;
     end if;
     fdr:=to_char(acc_dr,'99999999990');

     -- #------ Executions ----------
     if ( (p.executions-old_ex)>= 0 ) then 
          acc_ex:=acc_ex+(p.executions-old_ex);
     else
         acc_ex:=acc_ex+p.executions;
     end if;
     fex:=to_char(acc_ex,'99999999990');

     -- #------ Buffer gets --------
     if ( (p.buffer_gets-old_bg)>= 0 ) then 
          acc_bg:=acc_bg+(p.buffer_gets-old_bg);
     else
         acc_bg:=acc_bg+p.buffer_gets;
     end if;
     fbg:=to_char(acc_bg,'99999999990');

     -- #------ Sorts -------------
     if ( (p.sorts-old_sr)>= 0 ) then 
          acc_sr:=acc_sr+(p.sorts-old_sr);
     else
         acc_sr:=acc_sr+p.sorts;
     end if;
     fsr:=to_char(acc_sr,'99999999990');

     -- #------ cpu time ----------
     if ( (p.cpu_time-old_ct)>= 0 ) then 
          acc_ct:=acc_ct+(p.cpu_time-old_ct);
     else
         acc_ct:=acc_ct+p.cpu_time;
     end if;
     fct:=lpad(to_char(acc_ct/1000000),10);

     old_rp:=p.rows_processed;
     old_dr:=p.disk_reads;
     old_ex:=p.executions;
     old_bg:=p.buffer_gets;
     old_sr:=p.sorts;
     old_ct:=p.cpu_time;
     old_time:=p.Time;

     if (flag = 1 ) then
         flag:=2 ;
         next_time:=to_date(p.time,'HH24:MI:SS') + gr_min/1440 ;
     end if;
     if (flag = 0 ) then
        flag:=1 ;
        next_time:=to_date('00:00:00','HH24:MI:SS')  ;
     end if;

  END LOOP;
        dbms_output.put_line(old_time||' ' ||frp ||' '|| fdr || ' '||fex || ' '||fbg|| ' '|| fsr||' '||fct);
end;
/
EOF
   # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   fi
   # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#--dbms_output.put_line('acc_rp=' || to_char(acc_rp));
        #dbms_output.put_line('S:'||p.Time||' ' ||to_char(p.rows_processed,'99999999990') ||' '|| to_char(p.disk_reads,'99999999990') || ' '||to_char(p.executions,'99999999990') || ' '||to_char(p.buffer_gets,'99999999990')|| ' '|| to_char(p.executions,'99999999990')||' '||to_char(p.cpu_time,'99999999990'));
#-- dbms_output.put_line('p.disk_reads='|| to_char(p.disk_reads)|| '  fdr='|| fdr || '  old_dr =' || to_char(old_dr) );
#-- dbms_output.put_line('p.time:='||p.time || ' old_time='|| old_time || ' rp=' || to_char(p.rows_processed) || ' old_rp=' || to_char(old_rp) );
#-- dbms_output.put_line('gr_min='||to_char(gr_min)|| '  next_time='||to_char(next_time,'YYYYMMDDHH24MISS'));
# .................................................................
elif [ "$MODULE" = "TSEG" ];then

check_correct_external SAMPLE_SQL_W 
echo "MACHINE $HOSTNAME - ORACLE_SID : $ORACLE_SID                   Page: 1"
   sqlplus -s "$CONNECT_STRING" <<EOF
set heading off embedded off pause off verify off feed off pause off
set linesize 125 pagesize 66
column nline newline

select 'Date              -  '||to_char(sysdate,'Day Ddth Month YYYY  HH24:MI:SS'),
       'Username          -  '||USER,
       'Report            -  Top $ROWNUM events for $SPL nline'
from sys.dual
/
set heading on
column tot new_value tot noprint
column event format A25 head 'Event name'
column segment_name format A32 head 'Segment name'
column segt format A9 head 'Type' justify c
column Perc format 990.99 head 'Sample|Perc' justify c
column nw format 999999 head 'Nbr|waits' justify c
column swt format 99999999 head 'Time|waits' justify c
column sql_id format a13 head 'SQL|Hash Value' justify c
$PROMPT
select sum(cpt) tot from ( select count(wait_time) cpt from sample_sql_w )
/ 
prompt Total number of entries in waits file : &tot
select nw,event,sql_id,swt, perc, segment_name, 
    decode (segment_type,'TABLE SUBPARTITION','TAB SUB','TABLE PARTITION','TAB PART',segment_type) segt
   from (
     select count(nbr_wait) nw,event, sql_id, sum(wait_time) swt, sum((nbr_wait/&tot) * 100) Perc, 
       segment_name, segment_type
           from ( select count(wait_time)nbr_wait,event,sql_id,p1,p2, sum(seconds_in_wait)  wait_time
                  from sample_sql_w 
                         where event in ('db file sequential read','db file scattered read','buffer busy waits',
                                         'buffer read retry','direct path write','db file single write',
                                         'free buffer waits')
                   group by sql_id, event, p1,p2 order by 1 desc,3,2 ), 
                dba_extents 
            where  p1 = file_id and 
                   p2 >= block_id and 
                   p2 <= block_id+blocks 
                   group by event, sql_id, segment_name, segment_type order by nw desc, sql_id,event )
where rownum <=$ROWNUM
/
prompt
EOF
# .................................................................
elif [ "$MODULE" = "ENQUEUE" ];then
     if [ -n "$HV" ];then
          WHERE=" where sql_id = '$HV' "
          if [ $ROWNUM -eq 10 ];then
               ROWNUM=50
          fi
          PROMPT="prompt  .     Type 'spl -h' for help          Displaying $ROWNUM rows"
     fi
     check_correct_external SAMPLE_SQL_W 
     echo "MACHINE $HOSTNAME - ORACLE_SID : $ORACLE_SID                   Page: 1"
     sqlplus -s "$CONNECT_STRING" <<EOF
set heading off embedded off pause off verify off feed off pause off
set linesize 125 pagesize 66
column nline newline

select 'Date              -  '||to_char(sysdate,'Day Ddth Month YYYY  HH24:MI:SS'),
       'Username          -  '||USER,
       'Report            -  Top $ROWNUM events for $SPL nline'
from sys.dual
/
set heading on
column tot new_value tot noprint
column event format A30 head 'Event name'
column rwo format 99999999 head 'Row Wait|Obj Id' justify c
column obj format A$tlen head 'Object name'
column nbr_wait format 99999999 head 'Nbr Wait'
column Perc format 990.99 head 'Sample|Perc' justify c
$PROMPT
select count(1) tot from sample_sql_w
/ 
prompt Total number of entries in waits file : &tot
select nbr_wait, event, $SQL_ID  
     chr(bitand(p1,-16777216)/16777215)|| chr(bitand(p1, 16711680)/65535) "Lock" , bitand(p1, 65536) "Mode" 
, wait_time, (nbr_wait/&tot) * 100 Perc
from ( select count(wait_time)nbr_wait, event, $SQL_ID p1 ,sum(seconds_in_wait) wait_time
 from sample_sql_w where event = 'enqueue' group by $SQL_ID event, $SQL_ID  p1 order by 1 desc 
)  where rownum <= $ROWNUM
/
prompt
EOF
     #chr(bitand(p1,-16777216)/16777215)|| chr(bitand(p1, 16711680)/65535) "Lock" , bitand(p1, 65536) "Mode" 
 #from sample_sql_w group by event $SQL_ID $P1P2 order by 1 desc 
# .................................................................
elif [ "$MODULE" = "TOP10_WAIT" ];then
     if [ -n "$HV" ];then
          WHERE=" where"
          SQLTXT=" sql_id = '$HV' "
          if [ $ROWNUM -eq 10 ];then
               ROWNUM=50
          fi
     fi
     if [ -n "$TOP_EVENT" ];then
        if [ -z "$WHERE" ];then
           WHERE=where
        else
           AND=and
        fi
        SQLTXT="$SQLTXT $AND event = '$TOP_EVENT' "
        SQL_ID=" sql_id,"
     fi
     PROMPT="prompt  .     Type 'spl -h' for help          Displaying $ROWNUM rows"
     check_correct_external SAMPLE_SQL_W 
     echo "MACHINE $HOSTNAME - ORACLE_SID : $ORACLE_SID                   Page: 1"
     sqlplus -s "$CONNECT_STRING" <<EOF
set heading off embedded off pause off verify off feed off pause off
set linesize 125 pagesize 66
column nline newline

select 'Date              -  '||to_char(sysdate,'Day Ddth Month YYYY  HH24:MI:SS'),
       'Username          -  '||USER,
       'Report            -  Top $ROWNUM events for $SPL nline'
from sys.dual
/
set heading on
column tot new_value tot noprint
column event format A30 head 'Event name'
column rwo format 99999999 head 'Row Wait|Obj Id' justify c
column obj format A$tlen head 'Object name'
column nbr_wait format 99999999 head 'Nbr Wait'
column Perc format 990.99 head 'Sample|Perc' justify c
$PROMPT
select count(1) tot from sample_sql_w
/ 
prompt Total number of entries in waits file : &tot
select nbr_wait,event, $SQL_ID $P1P2 wait_time, (nbr_wait/&tot) * 100 Perc, (
      select owner||'.'||object_name from dba_objects where object_id=rwo) obj
from ( select count(wait_time)nbr_wait,event, $SQL_ID $P1P2
       sum(seconds_in_wait) wait_time, row_wait_obj# rwo
 from sample_sql_w $WHERE $SQLTXT group by $SQL_ID event, $P1P2 row_wait_obj# order by 1 desc 
)  where rownum <= $ROWNUM
/
prompt
EOF

# .................................................................
elif [ "$SHOW_SQL" = "YES" ];then

   check_correct_external SAMPLE_TXT_W 
   echo
   FSQL=$SBIN/tmp/hv_$HV.sql
   sqlplus -s "$CONNECT_STRING" > $FSQL <<EOF
set linesize 32767 pagesize 0 head off feed off
col sql_text format A64
break on sql_text
select sql_text from sample_txt_w where SQL_ID='$HV' order by piece
/
EOF
cat $FSQL | tr -d '\r' | tr -d '\n'
echo
# .................................................................
elif [ "$MODULE" = "PF_COUNT" ];then
   check_correct_external SAMPLE_EVT_W 
   case $GROUP_BY in
       sid|SID ) VAR_FIELD='sid,serial'; ORDER=sid ;;
       mod|MOD ) VAR_FIELD='module' ; ORDER=module;;
       act|ACT ) VAR_FIELD='action' ; ORDER=action;;
   esac
   sqlplus -s "$CONNECT_STRING"  <<EOF
set linesize 124 pagesize 66
col event format a40
select $VAR_FIELD,count(ddate),
       to_char(to_date(min(ddate),'YYYYMMDDHH24MISS'),'YYYY-MM-DD HH24:MI:SS') min_date,
       to_char(to_date(max(ddate),'YYYYMMDDHH24MISS'),'YYYY-MM-DD HH24:MI:SS') max_date
  from sample_evt_w group by $VAR_FIELD order by $ORDER;
EOF
# .................................................................
elif [ "$MODULE" = "PF_LIST" ];then
# ----------------------------------------------------------------------------------
#  This query is based on an idea of 'Alex Gorbachev' 2006 found on www.pythian.com
#  I have adapted to add some sorting option and date format, module and action
# ----------------------------------------------------------------------------------
   check_correct_external SAMPLE_EVT_W 
#set -x
   case $GROUP_BY in
       sid|SID ) AND_FIELD="and a.sid=$F_VALUE1 and a.serial=$F_VALUE2 "
                 VAR_FIELD_A="a.sid,a.serial"
                 VAR_FIELD="sid,serial"
                 FIELD_VALUE="sid=$F_VALUE1 and serial=$F_VALUE2";;
       mod|MOD ) AND_FIELD=" and a.module ='$F_VALUE' and a.module = b.module " 
                 VAR_FIELD_A="a.sid,a.module"
                 VAR_FIELD="sid,module"
                 FIELD_VALUE="module ='$F_VALUE'" 
                 SQL_MOD="select count(1) cpt_sid from (select sid,serial from sample_evt_w 
                                    where $FIELD_VALUE group by sid,serial);"
                 DIV_MOD="/nullif(&cpt_sid,0)"
                 PROMPT_MOD="prompt cpt_sid=&cpt_sid"
                 ;;
       act|ACT ) AND_FIELD=" and a.action='$F_VALUE' and a.action=b.action "
                 VAR_FIELD_A="a.action" 
                 VAR_FIELD="action" 
                 FIELD_VALUE="action='$F_VALUE'" ;;
   esac
   MIN=${MIN:-1440}
#   cat  <<EOF
   sqlplus -s "$CONNECT_STRING"  <<EOF
set linesize 124 pagesize 66
col event format a40
set heading off embedded off pause off verify off feed off pause off linesize 90 pagesize  999
column nline newline
column mindd new_value mindd noprint
column maxdd new_value maxdd noprint
column cpt_sid new_value cpt_sid noprint
select min(b.ddate) mindd from (select max(ddate) maxd from sample_evt_w ) a, sample_evt_w b  
	      	    where to_date(b.ddate,'YYYYMMDDHH24MISS') > to_date(a.maxd,'YYYYMMDDHH24MISS')-$MIN/1440 
                          and $FIELD_VALUE
/
select max(ddate) maxdd from sample_evt_w where $FIELD_VALUE ;
/
$SQL_MOD
$PROMPT_MOD
prompt min=&mindd
prompt max=&maxdd
set head on pagesize 66 linesize 124
col module format a30
col event format a30
col avg_ms format 9990.9
col p format 99990.99
select $VAR_FIELD,event,waits,
	round(time_micro/1000000,1) as sec,
	round(time_micro/nullif(waits,0)/1000,3) as avg_ms,
	round(ratio_to_report(time_micro)
		over (partition by $VAR_FIELD)*100 $DIV_MOD,1) as P,
	round(per_sec,2) as per_sec
from
	(select $VAR_FIELD_A,
	     decode(grouping_id(a.event),1,'CPU (~)',a.event) as event,
	     to_number(decode(grouping_id(a.event),1, null,sum(b.total_waits - a.total_waits))) as waits,
	     to_number(decode(grouping_id(a.event),1,
                 max((to_date(&maxdd,'YYYYMMDDHH24MISS')-to_date(&mindd,'YYYYMMDDHH24MISS'))*86400*1000000)-
	         sum(b.time_waited_micro-a.time_waited_micro), sum(b.time_waited_micro-a.time_waited_micro))) 
                 as time_micro,
             decode(grouping_id(a.event),0, sum(b.total_waits - a.total_waits)/
		nullif( sum(b.time_waited_micro-a.time_waited_micro),0)*1000000) as per_sec
	from sample_evt_w a, sample_evt_w b
	where a.event = b.event and a.sid = b.sid and a.serial = b.serial and
                a.ddate=&mindd  and
                b.ddate=&maxdd  $AND_FIELD
		group by $VAR_FIELD_A, rollup((a.event))
	) t
order by time_micro desc;
EOF
fi

if [ -n "$CREATE_IMAGE" ];then
    echo "Image required : calling $CREATE_IMAGE"
    $CREATE_IMAGE 
fi
